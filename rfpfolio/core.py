# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['PriceSource']

# Cell
import pandas as pd
import numpy as np
import array
import os.path

# Cell
class PriceSource:

    def __init__(self, data_root):
        """
        Args:
            data_root (str): Relative or absolute path to the root directory to load data from.
            In the root should be one or more directories named 'weekly', 'monthly', etc.
        """
        self.data_root = os.path.abspath(data_root)

    def __repr__(self):
        return (self.__class__.__qualname__ + f"(data_root={self.data_root})")

    def loadAdjustedPrices(self, ticker, subdir='weekly'):
        """
        Load data in to single column dataframe, indexed by date.
        The column has the name of the ticker, and is the adjusted price.
        Note: for Yahoo weekly data, the adj price is the adjusted closing price for the
        week beginning on the specified date.

        Args:
            ticker (str): Name of file to load, without '.csv' extension.
            subdir (str): Subdir of data_root wherein to find file to load.

        Returns:
            A dataframe with the specified data, indexed by date.
        """
        csv_path =  os.path.join(self.data_root, subdir, f"{ticker}.csv")
        prices = pd.read_csv(csv_path, parse_dates=[0])
        prices = prices[['Date', 'Adj Close']]
        prices.columns = ['Date', ticker]
        return prices.set_index('Date')

    def loadAllAdjustedPrices(self, tik_list, subdir='weekly'):
        """
        Load adjusted price data for all tickers to a dataframe, indexed by date.
        Each column name is a ticker, and the column values are the sequence of adjusted prices.

        Returns:
            A dataframe with the specified data, indexed by date.
        """
        tik_dict = {tik:  self.loadAdjustedPrices(tik, subdir) for tik in tik_list}
        return pd.concat([tik_dict[tik] for tik in tik_list], axis=1, join='inner')

# Internal Cell

def cum_wr_to_period_returns(cum_wr_ar, use_log = False):
    """
    Convert 1D array of cumulative wealth ratios to period fractional returns (0.01 = 1% return)
    The first element of `cum_wr_ar` is the wealth ratio for the corresponding period. (e.g., the first
    element will be 1.01 if the corresponding period return is 1%.)

    Cumulative wealth ratios are used in the computation of rebalanced portfolio returns; use this
    to convert from portfolio cum wr to portfolio period returns.

    Arguments:
        cum_wr_ar: numpy array - dim 0 is time

    Return:
        numpy array of period returns
    """
    # add initial 1 so the ratio of `cum_wr_ar` offset by one with itself will be period returns
    row1 = np.array([1.0])
    ar_plus = np.concatenate([row1, cum_wr_ar], 0)

    if use_log:
        return np.exp(np.log(ar_plus[1:]) - np.log(ar_plus[:-1])) - 1
    else:
        return ar_plus[1:] / ar_plus[:-1] - 1