# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['PriceSource', 'period_returns_from_prices', 'computePortfolioReturns']

# Cell
import pandas as pd
import numpy as np
import array
import os.path

# Cell
class PriceSource:

    def __init__(self, data_root):
        """
        Args:
            data_root (str): Relative or absolute path to the root directory to load data from.
            In the root should be one or more directories named 'weekly', 'monthly', etc.
        """
        self.data_root = os.path.abspath(data_root)

    def __repr__(self):
        return (self.__class__.__qualname__ + f"(data_root={self.data_root})")

    def loadAdjustedPrices(self, ticker, subdir='weekly'):
        """
        Load data in to single column dataframe, indexed by date.
        The column has the name of the ticker, and is the adjusted price.
        Note: for Yahoo weekly data, the adj price is the adjusted closing price for the
        week beginning on the specified date.

        Args:
            ticker (str): Name of file to load, without '.csv' extension.
            subdir (str): Subdir of data_root wherein to find file to load.

        Returns:
            A dataframe with the specified data, indexed by date.
        """
        csv_path =  os.path.join(self.data_root, subdir, f"{ticker}.csv")
        prices = pd.read_csv(csv_path, parse_dates=[0])
        prices = prices[['Date', 'Adj Close']]
        prices.columns = ['Date', ticker]
        return prices.set_index('Date')

    def loadAllAdjustedPrices(self, tik_list, subdir='weekly'):
        """
        Load adjusted price data for all tickers to a dataframe, indexed by date.
        Each column name is a ticker, and the column values are the sequence of adjusted prices.

        Returns:
            A dataframe with the specified data, indexed by date.
        """
        tik_dict = {tik:  self.loadAdjustedPrices(tik, subdir) for tik in tik_list}
        return pd.concat([tik_dict[tik] for tik in tik_list], axis=1, join='inner')

# Cell
def period_returns_from_prices(tik_prices, wr=False):
    """
    Given one or more sequences of prices, compute the returns over each adjacent pair of rows.
    Returns a dataframe containing period returns with row count one less than `tik_prices`.

    NOTE: You can also simply do: tik_prices.pct_change() for percent returns, or
    tik_prices.pct_change() + 1 for wealth ratios.

    Arguments:
        tik_prices: DataFrame of ordered prices: ticker column names, rows indexed by date
        wr: if true, returns are represented as wealth ratios (1.01 <=> 1% return), else as
        fractional returns (0.01 <=> 1% return)
    """
    prices = tik_prices.to_numpy()
    # 1st row of ratios is 2nd row of prices divided by first, & so forth
    ratios = prices[1:] / prices[:-1]
    returns = ratios - 1
    return pd.DataFrame(ratios if wr else returns, index=tik_prices.index[1:], columns=tik_prices.columns)

# Internal Cell
# Internal use: used in computation of portfolio returns.

def cum_wr_to_period_returns(cum_wr_ar, use_log = False):
    """
    Convert 1D array of cumulative wealth ratios to period fractional returns (0.01 = 1% return)
    The first element of `cum_wr_ar` is the wealth ratio for the corresponding period. (e.g., the first
    element will be 1.01 if the corresponding period return is 1%.)

    Cumulative wealth ratios are used in the computation of rebalanced portfolio returns; use this
    to convert from portfolio cumulative wr to portfolio period returns.

    Arguments:
        cum_wr_ar: numpy array - dim 0 is time

    Return:
        numpy array of period returns
    """
    # add initial 1 so the ratio of `cum_wr_ar` offset by one with itself will be period returns
    row1 = np.array([1.0])
    ar_plus = np.concatenate([row1, cum_wr_ar], 0)

    if use_log:
        return np.exp(np.log(ar_plus[1:]) - np.log(ar_plus[:-1])) - 1
    else:
        return ar_plus[1:] / ar_plus[:-1] - 1

# Internal Cell
def pf_cum_wr_seq(price_df, weights, rebal_period, normalize_wts=False):
    """
    Compute the sequence of cumulative portfolio wealth ratios from a sequence of asset prices, with
    rebalancing at a fixed interval.

    Args:
        price_df: Dataframe of asset returns as (noncumulative) wealth ratios, indexed by date
        weights [list]: portfolio weights for each asset ordered the same as columns of `price_df`
        rebal_period: length of the rebalance period, expressed in number of rows of `price_df`

    Returns:
        A python (double) array containing the sequence of portfolio values (cumulative wealth ratios)
    """
    # weights, as a 1-row 2D matrix
    weight_ar = np.array([weights])

    if normalize_wts:
        weight_ar = weight_ar / weight_ar.sum()

    # cols: wr's for a ticker.  rows: dates
    returns = price_df.to_numpy()

    period_start_ind = 0
    pf_val = 1

    # list of pf values:
    pf_values = array.array('d')

    while (period_start_ind < returns.shape[0]):
        # first row of array for cumprod is the initial capital per asset
        row_1 = weight_ar * pf_val

        # get the data for the next rebalance period
        rebal_period_return_data = returns[period_start_ind:period_start_ind+rebal_period]

        # Result of this operation: first row is initial capital per asset after rebalancing;
        # each subsequent row is the capital at subsequent dates
        ar_for_cumprod = np.append(row_1, rebal_period_return_data, axis=0)
        asset_values = np.cumprod(ar_for_cumprod, axis=0)

        # Compute sequence of portfolio values: sum of columns (asset vals) for each row.
        # Drop first value as it was the sum of the intitializing values (asset values).
        pf_rebal_period_values = np.sum(asset_values, axis=1)[1:]

        # append portfolio values for the rebalancing period to `pf_values`
        pf_values.extend(pf_rebal_period_values)

        # portfolio value at the end of the rebal period; use to compute starting capital
        # for each asset at the start of the next rebalancing period.
        pf_val = pf_rebal_period_values[-1]

        period_start_ind += rebal_period

    return pf_values

# Internal Cell
def pf_period_returns(price_df, weights, rebal_period, pf_name, pf_start_val = 1, normalize_wts=False):
    """
    Compute the sequence of portfolio period returns from a sequence of asset prices, with rebalancing
    at a fixed interval.

    Arguments:
        price_df: Dataframe of asset returns as (noncumulative) wealth ratios, indexed by date
        weights: portfolio weights for each asset ordered the same as columns of `price_df`
        pf_name: name for this portfolio -- will appear as column name
        rebal_period: length of the rebalance period, expressed in number of rows of `price_df`

    Returns:
        A DataFrame containing the sequence of portfolio period returns
    """
    # Compute portfolio cumulative wealth ratios (with rebalancing).
    pf_val_ar = np.asarray(pf_cum_wr_seq(price_df, weights, rebal_period, normalize_wts))

    # Cumulative wealth ratios to period returns
    pf_ret_ar = cum_wr_to_period_returns(pf_val_ar)

    return pd.DataFrame(pf_ret_ar, index=price_df.index, columns=[pf_name])

# Cell
def computePortfolioReturns(p_src: PriceSource, asset_weights, pf_name, rebal_period,
                            period='weekly',start_date='2017-05-01', normalize_wts=True):
    """
    Given tickers and their weights, compute the sequence of portfolio returns with rebalancing at the specified interval.

    Arguments:
        p_src
        asset_weights: dictionary from ticker to weight for this asset in pf (weights will)
        pf_name: name for this portfolio -- will appear as column name
        rebal_period: length of the rebalance period, expressed in number of rows of `price_df`
        period: 'weekly', or 'monthly'
        start_date: date of first period in sequence; first rebalance period begins with this period
        normalize_wts: if true, normalize weights to sum to 1

    Returns:
        A DataFrame containing the sequence of portfolio returns (value of 0.01 => 1% return), indexed by date.
    """
    adjPrices = p_src.loadAllAdjustedPrices(list(asset_weights.keys()), subdir=period)
    asset_returns = period_returns_from_prices(adjPrices, wr=True).loc[start_date:]

    return pf_period_returns(asset_returns,
                             list(asset_weights.values()),
                             rebal_period,
                             pf_name,
                             normalize_wts=normalize_wts).loc[start_date:]