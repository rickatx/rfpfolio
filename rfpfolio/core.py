# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['PriceSource', 'PSeg', 'SpliceSpec', 'period_returns_from_prices', 'pf_period_returns',
           'computePortfolioReturns', 'computePortfolioReturns2']

# Cell
import pandas as pd
import numpy as np
import array
import os.path
import glob
from dataclasses import dataclass
from datetime import datetime
from typing import List
from typing import NamedTuple

# Cell
class PriceSource:

    def __init__(self, data_root, subdir_default='weekly'):
        """
        Args:
            - data_root (str): Relative or absolute path to the root directory to load data from.
            - In the root should be one or more directories named 'weekly', 'monthly', etc.
        """
        self.data_root = os.path.abspath(data_root)
        self.subdir_default = subdir_default

    def __repr__(self):
        return (self.__class__.__qualname__ + f"(data_root={self.data_root})")

    def list_return_dates(self, subdir=None):
        """
        Print the range of return dates available for each csv file in the specified directory.
        """
        subdir =  subdir if subdir is not None else self.subdir_default
        glob_path = os.path.join(self.data_root, subdir, '*.csv')
        for path in glob.iglob(glob_path):
            prices = pd.read_csv(path, parse_dates=[0])
            start_date = prices.Date.iloc[0].date().isoformat()
            end_date = prices.Date.iloc[-1].date().isoformat()
            print(f"{start_date} => {end_date}  {os.path.basename(path)}")

    def loadAdjustedPrices(self, ticker, subdir=None):
        """
        Load data in to single column dataframe, indexed by date.
        The column has the name of the ticker, and is the adjusted price.
        Note: for Yahoo weekly data, the adj price is the adjusted closing price for the
        week beginning on the specified date.

        Args:
            - ticker (str): Name of file to load, without '.csv' extension.
            - subdir (str): Subdir of data_root wherein to find file to load.

        Returns:
            - A dataframe with the specified data, indexed by date.
        """
        subdir =  subdir if subdir is not None else self.subdir_default
        csv_path =  os.path.join(self.data_root, subdir, f"{ticker}.csv")
        prices = pd.read_csv(csv_path, parse_dates=[0])
        prices = prices[['Date', 'Adj Close']]
        prices.columns = ['Date', ticker]
        return prices.set_index('Date')


    def loadAllAdjustedPrices(self, tik_list, subdir=None):
        """
        Load adjusted price data for all tickers to a dataframe, indexed by date.
        Each column name is a ticker, and the column values are the sequence of adjusted prices.

        Returns:
            - A dataframe with the specified data, indexed by date.
        """
        subdir =  subdir if subdir is not None else self.subdir_default
        tik_dict = {tik:  self.loadAdjustedPrices(tik, subdir) for tik in tik_list}
        return pd.concat([tik_dict[tik] for tik in tik_list], axis=1, join='inner')

    def load_period_returns_ticker(self, ticker, subdir=None):
        """Submethod of load_period_returns(). Load period returns for an asset."""
        subdir =  subdir if subdir is not None else self.subdir_default
        df = self.loadAdjustedPrices(ticker, subdir)
        return df.pct_change().dropna()

    def load_period_returns(self, spec, subdir=None):
        """Load period returns for an asset, or a specified temporal sequence of assets.

        Args:
            - spec: Specifier of asset price data to load. Either a string (filename) or SpliceSpec
            - subdir: subdirectory of root to find data. Usual convention is to specify interval:
            'daily', 'weekly', 'monthly'
            - name: name for this asset return sequence (will be DataFrame's column name)

        Returns:
            - DataFrame of period returns for asset (or asset sequence) described by `spec`.
        """

        def date_selector(df, start, end):
            """Return a selector (boolean ndarray) of df for the specified start and end date.
            Selected rows have date index >= `start` and < `end`.
            """
            if start is None and end is None:
                # all rows
                return np.full(df.shape[0], True)
            elif start is None:
                return df.index < end
            elif end is None:
                return df.index >= start
            else:
                return (df.index >= start) & (df.index < end)

        subdir =  subdir if subdir is not None else self.subdir_default
        if isinstance(spec, str):
            return self.load_period_returns_ticker(spec, subdir)

        else:
            assert isinstance(spec, SpliceSpec)

            # with start_list = [d0, d1, d2], resulting date intervals are [d0, d1), [d1, d2), [d2, ..)
            start_list = [x.start for x in spec.sequence]
            df_seq = (self.load_period_returns_ticker(x.fname, subdir) for x in spec.sequence)

            # ... start_list, start_list[1:]+[None] -- this produces desired date intervals
            sub_dfs = [df[date_selector(df, start, end)] for df, start, end in zip(df_seq, start_list, start_list[1:]+[None])]

            # give the column of all sub_dfs the same name
            for df in sub_dfs:
                df.columns = [spec.name]

            return pd.concat(sub_dfs)

# Cell

@dataclass(frozen=True)
class PSeg:
    """Asset filename and start date -- used to specify sequential concatenations of various asset prices.
    """
    fname: str
    start: str

    def __post_init__(self):
        if self.start is None:
            return
        if not (isinstance(self.start, str) or isinstance(self.start, datetime)):
            raise ValueError("The date field must be a string or datetime")
        # confirm that the 'date' string can be converted to a pd.Timestamp
        pd.Timestamp(self.start)

    def __repr__(self):
        # Show how the date string will be interpreted as by pd.Timestamp -- e.g., '2015'
        # will be interpreted as the first day of the year, '2015-01-01'.
        date_str = pd.Timestamp(self.start).date().isoformat()
        return f"{self.__class__.__qualname__}(fname={self.fname}, start={date_str})"


class SpliceSpec(NamedTuple):
    """Specification for a data source created from a sequence of asset prices.

    Fields:
        - name: a name for the sequence
        - sequence: a list of PSeg, indicating a sequence of asset price segments
    """
    name: str
    sequence: List[PSeg]

# Cell
def period_returns_from_prices(tik_prices, wr=False):
    """
    Given one or more sequences of prices, compute the returns over each adjacent pair of rows.
    Returns a dataframe containing period returns with row count one less than `tik_prices`.

    NOTE: You can also simply do: tik_prices.pct_change() for percent returns, or
    tik_prices.pct_change() + 1 for wealth ratios.

    Arguments:
        tik_prices: DataFrame of ordered prices: ticker column names, rows indexed by date
        wr: if true, returns are represented as wealth ratios (1.01 <=> 1% return), else as
        fractional returns (0.01 <=> 1% return)
    """
    prices = tik_prices.to_numpy()
    # 1st row of ratios is 2nd row of prices divided by first, & so forth
    ratios = prices[1:] / prices[:-1]
    returns = ratios - 1
    return pd.DataFrame(ratios if wr else returns, index=tik_prices.index[1:], columns=tik_prices.columns)

# Internal Cell
# Internal use: used in computation of portfolio returns.

def cum_wr_to_period_returns(cum_wr_ar, use_log = False):
    """
    Convert 1D array of cumulative wealth ratios to period fractional returns (0.01 = 1% return)
    The first element of `cum_wr_ar` is the wealth ratio for the corresponding period. (e.g., the first
    element will be 1.01 if the corresponding period return is 1%.)

    Cumulative wealth ratios are used in the computation of rebalanced portfolio returns; use this
    to convert from portfolio cumulative wr to portfolio period returns.

    Arguments:
        cum_wr_ar: numpy array - dim 0 is time

    Return:
        numpy array of period returns
    """
    # add initial 1 so the ratio of `cum_wr_ar` offset by one with itself will be period returns
    row1 = np.array([1.0])
    ar_plus = np.concatenate([row1, cum_wr_ar], axis=0)

    if use_log:
        return np.exp(np.log(ar_plus[1:]) - np.log(ar_plus[:-1])) - 1
    else:
        return ar_plus[1:] / ar_plus[:-1] - 1

# Internal Cell
def pf_cum_wr_seq(price_df, weights, rebal_period, normalize_wts=False):
    """
    Compute the sequence of cumulative portfolio wealth ratios from a sequence of asset prices, with
    rebalancing at a fixed interval.

    Args:
        price_df: Dataframe of asset returns as (noncumulative) wealth ratios, indexed by date
        weights [list]: portfolio weights for each asset ordered the same as columns of `price_df`
        rebal_period: length of the rebalance period, expressed in number of rows of `price_df`

    Returns:
        A python (double) array containing the sequence of portfolio values (cumulative wealth ratios)
    """
    # weights, as a 1-row 2D matrix
    weight_ar = np.array([weights])

    if normalize_wts:
        weight_ar = weight_ar / weight_ar.sum()

    # cols: wr's for a ticker.  rows: dates
    returns = price_df.to_numpy()

    period_start_ind = 0
    pf_val = 1

    # list of pf values:
    pf_values = array.array('d')

    while (period_start_ind < returns.shape[0]):
        # first row of array for cumprod is the initial capital per asset
        row_1 = weight_ar * pf_val

        # get the data for the next rebalance period
        rebal_period_return_data = returns[period_start_ind:period_start_ind+rebal_period]

        # Result of this operation: first row is initial capital per asset after rebalancing;
        # each subsequent row is the capital at subsequent dates
        ar_for_cumprod = np.append(row_1, rebal_period_return_data, axis=0)
        asset_values = np.cumprod(ar_for_cumprod, axis=0)

        # Compute sequence of portfolio values: sum of columns (asset vals) for each row.
        # Drop first value as it was the sum of the intitializing values (asset values).
        pf_rebal_period_values = np.sum(asset_values, axis=1)[1:]

        # append portfolio values for the rebalancing period to `pf_values`
        pf_values.extend(pf_rebal_period_values)

        # portfolio value at the end of the rebal period; use to compute starting capital
        # for each asset at the start of the next rebalancing period.
        pf_val = pf_rebal_period_values[-1]

        period_start_ind += rebal_period

    return pf_values

# Cell
def pf_period_returns(price_df, weights, rebal_period, pf_name, pf_start_val = 1, normalize_wts=False):
    """
    Compute the sequence of portfolio period returns from a sequence of asset prices, with rebalancing
    at a fixed interval.

    Arguments:
        price_df: Dataframe of asset returns as (noncumulative) wealth ratios, indexed by date
        weights: portfolio weights for each asset ordered the same as columns of `price_df`
        pf_name: name for this portfolio -- will appear as column name
        rebal_period: length of the rebalance period, expressed in number of rows of `price_df`

    Returns:
        A DataFrame containing the sequence of portfolio period returns
    """
    # Compute portfolio cumulative wealth ratios (with rebalancing).
    pf_val_ar = np.asarray(pf_cum_wr_seq(price_df, weights, rebal_period, normalize_wts))

    # Cumulative wealth ratios to period returns
    pf_ret_ar = cum_wr_to_period_returns(pf_val_ar)

    return pd.DataFrame(pf_ret_ar, index=price_df.index, columns=[pf_name])

# Cell
def computePortfolioReturns(p_src: PriceSource, asset_weights, pf_name, rebal_period,
                            period='weekly',start_date='2017-05-01', normalize_wts=True, wr=False):
    """
    Given tickers and their weights, compute the sequence of portfolio returns with rebalancing at the specified interval.

    Arguments:
        p_src
        asset_weights: dictionary from ticker to weight for this asset in pf (weights will)
        pf_name: name for this portfolio -- will appear as column name
        rebal_period: length of the rebalance period, expressed in number of rows of `price_df`
        period: 'weekly', or 'monthly'
        start_date: date of first period in sequence; first rebalance period begins with this period
        normalize_wts: if true, normalize weights to sum to 1
        wr: if False, returns expressed as period returns (value of 0.01 => 1% return) else as wealth ratios
        (value of 1.01 => 1% return)

    Returns:
        A DataFrame containing the sequence of portfolio returns , indexed by date.
    """
    adjPrices = p_src.loadAllAdjustedPrices(list(asset_weights.keys()), subdir=period)
    asset_returns = period_returns_from_prices(adjPrices, wr=True).loc[start_date:]

    per_returns = pf_period_returns(asset_returns,
                             list(asset_weights.values()),
                             rebal_period,
                             pf_name,
                             normalize_wts=normalize_wts).loc[start_date:]
    if wr:
        return 1 + per_returns
    else:
        return per_returns

# Cell
def computePortfolioReturns2(p_src: PriceSource, asset_wt_list, pf_name, rebal_period,
                            period=None, start_date=None, normalize_wts=True, wr=False):
    """
    Given asset specs and their weights, compute the sequence of portfolio returns with rebalancing at the specified interval.

    Arguments:
     - p_src: PriceSource for price data
     - asset_wt_list: list of (asset_spec, asset_weight)
     - pf_name: name for this portfolio -- will appear as column name
     - rebal_period: length of the rebalance period, expressed in number of rows of `price_df`
     - period: Either None, 'daily', 'weekly', or 'monthly'. If None, use `p_src` default.
     - start_date: None or date of first period in sequence; first rebalance period begins with this period.
       If None, use first date available for all assets.
     - normalize_wts: if true, normalize weights to sum to 1
     - wr: if False, returns expressed as period returns (value of 0.01 => 1% return) else as wealth ratios
        (value of 1.01 => 1% return)

    Returns:
        A DataFrame containing the sequence of portfolio returns , indexed by date.
    """
    all_period_returns = [p_src.load_period_returns(spec, period) for spec, _ in asset_wt_list]
    asset_returns = pd.concat(all_period_returns, axis=1, join='inner')
    # return asset_returns
    asset_returns = asset_returns + 1  # returns as wealth ratios
    if start_date:
        asset_returns = asset_returns.loc[start_date:]

    per_returns = pf_period_returns(asset_returns,
                             [wt for _, wt in asset_wt_list],
                             rebal_period,
                             pf_name,
                             normalize_wts=normalize_wts)
    if wr:
        return 1 + per_returns
    else:
        return per_returns